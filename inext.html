<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vũ trụ </title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #0c0c35 0%, #1a1a4a 50%, #2a2a6a 100%);
      height: 100vh;
      width: 100vw;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div id="universePage"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const classImages = [];
    for (let i = 1; i <= 500; i++) {
      classImages.push(`image/${i}.jpg`);
      classImages.push(`image/${i}.jpeg`);
    }

    let scene, camera, renderer;
    let planet, rings = [], imageSprites = [], imageGroup;

    function init() {
      const container = document.getElementById("universePage");

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0a0a2a, 1);
      container.appendChild(renderer.domElement);

      createStars();
      createPlanet();
      createOrbitingRings();

      imageGroup = new THREE.Group();
      scene.add(imageGroup);

      camera.position.set(0, 10, 30);
      camera.lookAt(0, 0, 0);

      initSimpleControls();
      animate();
      startImageCycling();

      window.addEventListener('resize', onWindowResize);
    }

    function createStars() {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(2000 * 3);
      for (let i = 0; i < 2000; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
      const stars = new THREE.Points(geometry, material);
      scene.add(stars);
    }

    function createPlanet() {
      const geometry = new THREE.SphereGeometry(3, 32, 32);
      const material = new THREE.MeshPhongMaterial({
        color: 0x8844ff,
        emissive: 0x221144,
        shininess: 100,
        transparent: true,
        opacity: 0.9
      });
      planet = new THREE.Mesh(geometry, material);
      scene.add(planet);

      const ambient = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambient);
      const light = new THREE.PointLight(0x8844ff, 1, 100);
      light.position.set(10, 10, 10);
      scene.add(light);
    }

    function createOrbitingRings() {
      const ringsData = [8, 12, 16];
      ringsData.forEach((r, i) => {
        const ringGeo = new THREE.RingGeometry(r, r + 0.3, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x6644ff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2 + (i - 1) * 0.1;
        scene.add(ring);
        rings.push(ring);
      });
    }

    function createImageSprite(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const maxSize = 2;
          const aspect = img.width / img.height;
          let w = aspect > 1 ? maxSize : maxSize * aspect;
          let h = aspect > 1 ? maxSize / aspect : maxSize;
          canvas.width = 256; canvas.height = 256;
          const dw = canvas.width * 0.9;
          const dh = dw / aspect;
          const x = (canvas.width - dw) / 2;
          const y = (canvas.height - dh) / 2;
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, x, y, dw, dh);
          ctx.shadowColor = 'rgba(136, 68, 255, 0.5)';
          ctx.shadowBlur = 20;
          ctx.strokeStyle = 'rgba(136, 68, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, dw, dh);
          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.8 });
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(w, h, 1);
          resolve(sprite);
        };
        img.onerror = () => reject();
        img.src = url;
      });
    }

    function startImageCycling() {
      let index = 0;
      async function update() {
        imageSprites.forEach(s => {
          imageGroup.remove(s);
          if (s.material.map) s.material.map.dispose();
          s.material.dispose();
        });
        imageSprites = [];
        const count = 12;
        const promises = [];
        for (let i = 0; i < count; i++) {
          const idx = (index + i) % classImages.length;
          promises.push(createImageSprite(classImages[idx]));
        }
        try {
          const sprites = await Promise.all(promises);
          sprites.forEach((sprite, i) => {
            const angle = (i / count) * Math.PI * 2;
            const radius = 20;
            sprite.position.set(Math.cos(angle) * radius, Math.sin(i * 0.5) * 2, Math.sin(angle) * radius);
            imageGroup.add(sprite);
            imageSprites.push(sprite);
          });
          index = (index + count) % classImages.length;
        } catch {}
      }
      update();
      setInterval(update, 8000);
    }

    function animate() {
      TWEEN.update();
      if (planet) planet.rotation.y += 0.01;
      rings.forEach((r, i) => r.rotation.z += 0.002 * (i + 1));
      if (imageGroup) imageGroup.rotation.y += 0.003;
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function initSimpleControls() {
      const canvas = renderer.domElement;
      let down = false, startX = 0, startY = 0, tx = 0, ty = 0, cx = 0, cy = 0;
      canvas.addEventListener('mousedown', e => { down = true; startX = e.clientX; startY = e.clientY; });
      canvas.addEventListener('mouseup', () => { down = false; });
      canvas.addEventListener('mousemove', e => {
        if (!down) return;
        tx += (e.clientX - startX) * 0.01;
        ty += (e.clientY - startY) * 0.01;
        startX = e.clientX; startY = e.clientY;
      });
      canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const s = e.deltaY > 0 ? 1.1 : 0.9;
        camera.position.multiplyScalar(s);
        const d = camera.position.length();
        if (d < 10) camera.position.normalize().multiplyScalar(10);
        if (d > 100) camera.position.normalize().multiplyScalar(100);
      });
      function updateCam() {
        cx += (tx - cx) * 0.05;
        cy += (ty - cy) * 0.05;
        cy = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cy));
        const d = camera.position.length();
        camera.position.x = d * Math.cos(cy) * Math.cos(cx);
        camera.position.y = d * Math.sin(cy);
        camera.position.z = d * Math.cos(cy) * Math.sin(cx);
        camera.lookAt(0, 0, 0);
        requestAnimationFrame(updateCam);
      }
      updateCam();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
